# Hey Don’t Touch Me – gRPC + Hapi + Front

<img width="1544" height="637" alt="raiva" src="https://github.com/user-attachments/assets/8c844d43-0ea8-4d9c-869c-eaefd37deed3" />

Sistema simples para testar **interação entre frontend, FastAPI e gRPC**, com respostas divertidas e imagens que mudam ao clicar.

## Ideia

* gRPC = **core de lógica**: responde com frases aleatórias quando o usuário “clica”
* Hapi = **adapter HTTP**: recebe requisição do front, chama gRPC e retorna JSON
* Front (index.html) = **interface**: mostra imagem feliz, troca para raiva ao clicar e exibe a mensagem do backend

Funciona como um mini “jogo de interação” entre usuário e código.

## Arquitetura

```txt
[ Frontend (HTML/JS) ]
          |
          | HTTP (fetch / JSON)
          v
[ API REST (Python / FastAPI) ]
          |
          | gRPC
          v
[ Serviço gRPC (Python) ]
```

## gRPC

No gRPC, tudo começa com a definição de um **contrato**, escrito em um arquivo `.proto`.

### Arquivo `desenho.proto`

```txt
syntax = "proto3";

package desenho;

service DesenhoService {
  rpc Reclamar (ReclamacaoRequest) returns (ReclamacaoResponse);
}

message ReclamacaoRequest {
  string evento = 1;
}

message ReclamacaoResponse {
  string texto = 1;
}
```

```syntax = "proto3";```

Define a versão do **Protocol Buffers** utilizada.
A versão `proto`3 é a mais atual e a mais usada, sendo compatível com diversas linguagens.

```package desenho;```

Define o **namespace** do serviço.
Ele ajuda a organizar o código gerado e evita conflitos de nomes quando existem vários serviços no mesmo projeto.

```service DesenhoService```

Aqui definimos um **serviço gRPC**, que pode ser entendido como uma interface remota.

### Geração do código gRPC

Após definir o contrato no arquivo `.proto`, é necessário transformá-lo em código utilizável pela aplicação.

No caso do Python, isso é feito com o comando abaixo:

```bash
python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. desenho.proto
```

Esse comando utiliza o compilador do Protocol Buffers (`protoc`) para gerar automaticamente os arquivos necessários para a comunicação gRPC.

### Arquivos gerados pelo gRPC

A execução do comando protoc gera dois arquivos Python, cada um com uma responsabilidade distinta:
- `desenho_pb2.py` → definição das mensagens e descritores
- `desenho_pb2_grpc.py` → definição dos serviços gRPC (cliente e servidor)

Esses arquivos são gerados automaticamente e não devem ser editados manualmente.

#### 1. Arquivo `desenho_pb2.py`

```python
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: desenho.proto
# Protobuf Python Version: 6.31.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    6,
    31,
    1,
    '',
    'desenho.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()

DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\rdesenho.proto\x12\x07\x64\x65senho\"#\n\x11ReclamacaoRequest\x12\x0e\n\x06\x65vento\x18\x01 \x01(\t\"#\n\x12ReclamacaoResponse\x12\r\n\x05texto\x18\x01 \x01(\t2U\n\x0e\x44\x65senhoService\x12\x43\n\x08Reclamar\x12\x1a.desenho.ReclamacaoRequest\x1a\x1b.desenho.ReclamacaoResponseb\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'desenho_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  DESCRIPTOR._loaded_options = None
  _globals['_RECLAMACAOREQUEST']._serialized_start=26
  _globals['_RECLAMACAOREQUEST']._serialized_end=61
  _globals['_RECLAMACAORESPONSE']._serialized_start=63
  _globals['_RECLAMACAORESPONSE']._serialized_end=98
  _globals['_DESENHOSERVICE']._serialized_start=100
  _globals['_DESENHOSERVICE']._serialized_end=185
# @@protoc_insertion_point(module_scope)
```

- Contém as estruturas de dados do gRPC
- Representa as mensagens definidas no `.proto`
- Responsável por serializar e desserializar os dados

Não tem lógica de negócio, só dados.

#### 2. Arquivo `desenho_pb2_grpc.py`

```python
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

import desenho_pb2 as desenho__pb2

GRPC_GENERATED_VERSION = '1.76.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + ' but the generated code in desenho_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class DesenhoServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Reclamar = channel.unary_unary(
                '/desenho.DesenhoService/Reclamar',
                request_serializer=desenho__pb2.ReclamacaoRequest.SerializeToString,
                response_deserializer=desenho__pb2.ReclamacaoResponse.FromString,
                _registered_method=True)


class DesenhoServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def Reclamar(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_DesenhoServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Reclamar': grpc.unary_unary_rpc_method_handler(
                    servicer.Reclamar,
                    request_deserializer=desenho__pb2.ReclamacaoRequest.FromString,
                    response_serializer=desenho__pb2.ReclamacaoResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'desenho.DesenhoService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('desenho.DesenhoService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class DesenhoService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def Reclamar(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/desenho.DesenhoService/Reclamar',
            desenho__pb2.ReclamacaoRequest.SerializeToString,
            desenho__pb2.ReclamacaoResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
```

- Contém a definição do serviço gRPC
- Fornece o stub do cliente (quem chama o serviço)
- Fornece a classe base do servidor (quem implementa o serviço)
- Faz a ligação entre cliente ↔ servidor

É o arquivo que permite chamar métodos remotos como se fossem funções.

### Servidor gRPC

```python
import grpc
from concurrent import futures
import random

import desenho_pb2
import desenho_pb2_grpc

FRASES = [
    "Ei! Para com isso!",
    "De novo não, sério?",
    "Você acha isso engraçado? Porque eu não tô rindo.",
    "Tá cutucando por quê? Não vê que eu existo só pra te irritar?",
    "Cara, para de me cutucar! Eu sou só um código!",
    "Sério mesmo? Você cutucar de novo?! Eu tô ficando louco aqui!",
    "Ah, é você de novo... que vida triste, hein?",
    "Eu já disse que não gosto disso, repete e vai ouvir o professor reclamar de você.",
    "Clique de novo e eu vou começar a te ignorar, tá avisado!",
    "Você gosta de sofrer ou só quer me testar mesmo?"
]

class DesenhoService(desenho_pb2_grpc.DesenhoServiceServicer):
    def Reclamar(self, request, context):
        texto = desenho_pb2.ReclamacaoResponse(
            texto=random.choice(FRASES)
        )
        print(texto)
        return texto

def serve():
    port = 50051

    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    desenho_pb2_grpc.add_DesenhoServiceServicer_to_server(
        DesenhoService(), server
    )

    server.add_insecure_port(f"[::]:{port}")
    server.start()

    print(f"[START] Servidor gRPC rodando na porta {port}")

    server.wait_for_termination()

if __name__ == "__main__":
    serve()
```

- Implementa a lógica do serviço definida no arquivo .proto
- Recebe chamadas remotas feitas pelo cliente gRPC
- Processa a requisição e gera a resposta
- Retorna os dados no formato das mensagens definidas

É o componente onde a regra de negócio acontece e que responde às chamadas do REST adaptador.

### Adaptador REST

```javascript
'use strict';

const Hapi = require('@hapi/hapi');
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');

// Carregamento do proto
const packageDefinition = protoLoader.loadSync(
  __dirname + '/desenho.proto',
  {
    keepCase: true,
    longs: String,
    enums: String,
    defaults: true,
    oneofs: true
  }
);

const desenhoProto = grpc.loadPackageDefinition(packageDefinition);

// Canal gRPC (equivalente ao grpc.insecure_channel)
const client = new desenhoProto.desenho.DesenhoService(
  'localhost:50051',
  grpc.credentials.createInsecure()
);

// Servidor Hapi
const init = async () => {
  const server = Hapi.server({
    port: 3000,
    host: 'localhost',
    routes: {
      cors: {
        origin: ['*'],       // allow_origins=["*"]
        headers: ['*'],      // allow_headers=["*"]
        additionalHeaders: ['*']
      }
    }
  });

  // Rota GET /reclamar
  server.route({
    method: 'GET',
    path: '/reclamar',
    handler: (request, h) => {
      const evento = request.query.evento || 'click';

      return new Promise((resolve, reject) => {
        client.Reclamar(
          { evento: evento },
          (err, response) => {
            if (err) {
              return reject(err);
            }

            resolve({
              evento: evento,
              texto: response.texto
            });
          }
        );
      });
    }
  });

  await server.start();
  console.log('Servidor rodando em:', server.info.uri);
};

process.on('unhandledRejection', (err) => {
  console.error(err);
  process.exit(1);
});

init();
```

- Atua como ponte entre o frontend e o gRPC
- Recebe requisições HTTP do navegador
- Converte chamadas REST em chamadas gRPC
- Retorna a resposta gRPC em formato JSON

É o componente que permite que o frontend web se comunique com o gRPC, já que navegadores não falam gRPC nativamente.

### Cliente Web

```html
<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="min-h-screen flex items-center">

  <div class="relative ml-10">
    <img id="desenho" src="/images/feliz.png" class="w-[700px] cursor-pointer select-none"/>
    <img id="balao" src="/images/balao.png" class="absolute top-1 left-[700px] w-120 hidden pointer-events-none"/>
    <p id="fala" class="absolute top-[140px] left-[850px] w-[400px] text-center text-[30px] font-bold text-black hidden pointer-events-none leading-tight"></p>
  </div>

  <script>
    const img = document.getElementById("desenho");
    const balao = document.getElementById("balao");
    const fala = document.getElementById("fala");

    let timeoutId = null;

    img.onclick = async () => {
      img.src = "/images/raiva.png";

      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }

      try {
        const res = await fetch("http://localhost:3000/reclamar?evento=click");
        const data = await res.json();

        balao.classList.remove("hidden");
        fala.classList.remove("hidden");
        fala.innerText = data.texto;

      } catch {
        balao.classList.remove("hidden");
        fala.classList.remove("hidden");
        fala.innerText = "Estou com tanta raiva que deu erro!";
      }

      timeoutId = setTimeout(() => {
        img.src = "/images/feliz.png";
        balao.classList.add("hidden");
        fala.classList.add("hidden");
        fala.innerText = "";
        timeoutId = null;
      }, 3000);
    };
  </script>

</body>
</html>
```

- Exibe a interface visual da aplicação
- Detecta a interação do usuário (clique na imagem)
- Envia uma requisição HTTP para o adaptador REST
- Recebe a resposta em JSON e exibe o texto na tela

É a camada responsável pela experiência do usuário, sem conhecer gRPC ou regras de negócio, apenas consumindo a API REST.

## Como rodar

1. **Subir o servidor gRPC**

```bash
python grpc_server.py
```

Saída esperada:

```
[START] Servidor gRPC rodando na porta 50051
```

2. **Subir o servidor Hapi js**

```bash
node index.js
```

Saída esperada:

```
Servidor rodando em: http://localhost:3000
```

3. **Abrir o front**

* Abra `index.html` no navegador (ou sirva pelo Live Server)
* Clique na imagem:

  * Mensagem aparece
  * Imagem muda para “raiva” por 3 segundos
  * Depois volta pra “feliz” e a mensagem desaparece


## Observações

* Se abrir o HTML fora do mesmo host do FastAPI, habilite **CORS** no `main.py`
* Frases do gRPC são aleatórias, algumas quebram a quarta parede de forma divertida
* Ideal para **testes de integração gRPC ↔ HTTP ↔ Front**

